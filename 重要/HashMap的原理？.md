`Java 集合`

## 原理

HashMap是通过**对 key 的 hash 值进行转换**来定位每个 key 在内部数组上的位置。HashMap 是实现原理是**数组 + 链表**，Java 1.8 以后加入了**红黑树**。

## Key的Hash值计算

第一步：**正常计算出 key 的 hash 值**（调用 key 的 hashCode() 方法，如果 key 是 null 则其 hash 值是0）；
第二步：**对得到的 hash 值进行扰乱**，目的是为了让 hash 值能尽可能的均匀分布。


## 问题

#### 1. 为什么不直接使用 key 而要使用 key 的 hash 值？
答：考虑到效率问题如果直接使用 key，那么在查找的时候需要调用 key 的 equals() 方法去逐个比较，时间复杂度从原本的 **O(1)** 变成了 **O(n)** ，且 equals() 比较的效率也很低，而通过 hash 值可以直接定位到桶。

#### 2. 那为什么又不直接用 hash 值作为数组上的索引？
答：**为了防止数组下标越界**，因为 hash 值不确定性，很容易越界。

#### 3. 那为什么用的是 (n - 1) & hash，而不是 hash % n 呐？
答：其实早期版本就是用 hash % n，但是为了追求效率，后来就改成了位运算 (n - 1) & hash（位运速度比取余算快，注意：%是取余不是取模），
**当 n 为 2 的指数，(n - 1) & hash 与 hash % n是等价的**

#### 4. 为什么 (n - 1) & hash 和 hash % n 是等价的？
答：这里利用了 HashMap 的一个特性：HashMap 规定其容量必须是 2 的 n 次方（最大为 230 次方）,那么 n 肯定就是 2xx 次方了，用二进制表示就是 1000...00，最前面是 1，后面全是 0（假设有k个0），那么 n-1 就全变成 1 了 111...1111（k-1个1），hash ^ (n - 1) 得到的最大值就是 n-1，最小值是 0。效果和hash % n 一样，只是改为位运算了。位运算比取模运算更快。

#### 5. 为什么 HashMap 的容量是 2 的幂次方（参考问题 4）
答：是为了 hash 值的计算，早期版本的 hash 值计算是 hash % n，来得到一个数组范围内的 hash 值，而当容量为2的幂次方（其二进制永远是100.....，再减去1，就是全部都是11111，方便做与运算），通过 (n - 1) & hash 来计算哈希值，会更加效率。


## 链接

[CSDN：Java（Android）数据结构汇总（四）-- Map（上）](https://www.jianshu.com/p/4c9576780588)