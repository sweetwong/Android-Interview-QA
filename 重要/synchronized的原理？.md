`Java 并发`

## 原理

synchronized 的底层是使用操作系统的 **mutex lock**（互斥锁）实现的。

## 四种场景
1. 实例方法，实例方法，被锁：类的实例对象

2. 静态方法，类对象，被锁：类

3. 代码块，实例对象，被锁：类的实例对象

4. 代码块，类对象，被锁：类

## 过程
执行同步代码块后首先要先执行 **monitorenter** 指令，退出的时候 **monitorexit** 指令。通过分析之后可以看出，使用 synchronized 进行同步，其关键就是必须要对象的监视器 monitor 进行获取，当线程获取 monitor 后才能继续往下执行，否则就只能等待。而这个获取的过程是互斥的，即同一时刻只有一个线程能够获取到 monitor 。

在同一锁程中，线程不需要再次获取同一把锁。synchronized 先天具有重入性，**每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。

**任意一个对象都拥有自己的监视器**，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到 BLOCKED 状态。

![](../assets/锁获取.png)

## 偏向锁/轻量级锁/重量级锁
锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）

0. **无锁状态**

1. **偏向锁**（乐观锁，重入锁，偏向第一个线程）：偏向锁是指一段同步代码 **一直被同一个线程** 所访问，那么该线程会自动获取锁，降低获取锁的代价，做法是通过比较 **Mark Word** 的 **Thread ID**

2. **轻量级**（乐观锁，另一个线程自旋）：轻量级锁是指当锁是偏向锁的时候，**被另一个线程所访问**，偏向锁就会升级为轻量级锁，其他线程会通过 **自旋** 的形式尝试获取锁，不会阻塞，提高性能

3. **重量级锁**（条件：**3 个或 3 个以上的线程竞争或者自旋超过一定次数**）：重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低

PS：**JDK 1.6** 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“偏向锁”和“轻量级锁”，**这两种锁都是乐观锁**

## 原理图
![](../assets/synchronized原理图.jpg)

## 链接
[Github：android_interview：synchronized-reentrantlock](https://github.com/LRH1993/android_interview/blob/master/java/concurrence/synchronized-reentrantlock.md)

[知乎：Java synchronized原理总结（比较底层）](https://zhuanlan.zhihu.com/p/29866981)

[简书：让你彻底理解synchronized](https://www.jianshu.com/p/d53bf830fa09)

[知乎：互斥锁（mutex）的底层原理是什么？ 操作系统具体是怎么实现的？？](https://www.zhihu.com/question/332113890)