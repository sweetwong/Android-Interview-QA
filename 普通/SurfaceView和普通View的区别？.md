### 区别

1. View底层没有双缓冲机制，SurfaceView有**双缓冲机制**；

2. View主要适用于主动更新，而SurfaceView**适用与被动的更新**，如频繁的刷新

3. View会在主线程中去更新UI，而SurfaceView则在**子线程中刷新**；


### 特征
SurfaceView中采用了双缓冲机制，保证了UI界面的流畅性，同时 SurfaceView不在主线程中绘制，而是另开辟一个线程去绘制，所以它不妨碍UI线程；

* View：显示视图，内置画布，提供图形绘制函数、触屏事件、按键事件函数等；必须在UI主线程内更新画面，速度较慢。

* SurfaceView：基于view视图进行拓展的视图类，更适合2D游戏的开发；是view的子类，类似使用双缓机制，在新的线程中更新画面所以刷新界面速度比view快，Camera预览界面使用SurfaceView。

* GLSurfaceView：基于SurfaceView视图再次进行拓展的视图类，专用于3D游戏开发的视图；是SurfaceView的子类，OpenGL专用。 如何实现进程保活


### 问题的由来
<u>CPU访问内存的速度要远远快于访问屏幕的速度</u>。如果需要绘制大量复杂的图像时，每次都一个个从内存中读取图形然后绘制到屏幕就会造成多次地访问屏幕，从而导致效率很低。这就跟CPU和内存之间还需要有三级缓存一样，需要提高效率。

#####   第一层缓冲
在绘制图像时不用上述一个一个绘制的方案，<u>而采用先在内存中将所有的图像都绘制到一个Bitmap对象上，然后一次性将内存中的Bitmap绘制到屏幕，从而提高绘制的效率</u>。Android中View的onDraw()方法已经实现了这一层缓冲。onDraw()方法中不是绘制一点显示一点，而是都绘制完后一次性显示到屏幕。

##### 第二层缓冲

onDraw()方法的Canvas对象是和屏幕关联的，而onDraw()方法是运行在UI线程中的，如果要绘制的图像过于复杂，则有可能导致应用程序卡顿，甚至ANR。<u>因此我们可以先创建一个临时的Canvas对象，将图像都绘制到这个临时的Canvas对象中，绘制完成之后再将这个临时Canvas对象中的内容(也就是一个Bitmap)，通过drawBitmap()方法绘制到onDraw()方法中的canvas对象中</u>。这样的话就相当于是一个Bitmap的拷贝过程，比直接绘制效率要高，可以减少对UI线程的阻塞。

### 链接
[简书：Android自定义View之双缓冲机制和SurfaceView](https://www.jianshu.com/p/afe23814b207)