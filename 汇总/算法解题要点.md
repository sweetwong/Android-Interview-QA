## 算法解题步骤
1. 读题：看清题目，寻找关键字，如要求 O(nlogn) 复杂度，应该立刻想到二分查找，看到链表问题，立刻想到头节点和双指针

2. 得出解题思路：先想好要用什么方法，可以打下草稿，不要急着写代码
3. 将思路转变为代码：记住这三者不能乱，必须要按顺序来，不能没有思路瞎写代码，如果实在没有很好的思路，可以尝试先用比较粗暴的方法解决问题

## 读题到方法（认识关键字）

- 有序数组，复杂度为 O(nlogn) -> 二分查找，快排思想，归并思想，堆排序思想
- 生成所有结果 -> 回溯，试错，全排列问题
- 前 k 个 -> 优先队列（堆排序），快排分区
- 重复子问题 -> 动态规划
- 无额外的空间复杂度 -> 原地算法，数组相关的操作
- 多重依赖关系 -> 图，拓扑排序
- 大问题转小问题 -> 递归  -> 动态规划
- 如果需要找到左边或者右边第一个比当前位置的数大或者小 -> 单调栈

通用思路 -> 考虑使用栈、队列（双端队列更好用）、哈希表、Set 等数据结构解决问题

## 各类型问题解题技巧

### 链表

1. 虚节点（dummyHead）
2. 双指针（快慢指针，等距指针，...）
3. 善于拆分和组合链表
4. 善用反转操作
5. 善用归并操作
6. 注意：链表很容易形成循环链表，注意及时进行拆分操作，curr.next = null 来避免循环链表

### 树

- **递归**，几乎所有的树的问题都要用到递归
- 善于利用 **返回值**（如果是构建树，返回值应该是一个 TreeNode；甚至可以返回数组，就是返回子节点的三个节点信息）
- 栈，非递归实现 DFS
- 队列，实现 BFS

### 二叉搜索树

* 若左子树不为空，左子树上**所有**的节点小于根节点

* 若右子树不为空，右子树上**所有**的节点大于根节点

* 左子树和右子树都是二叉搜索树

特征：中序遍历是有序的

### 图

- BFS 和 DFS
- 图的存储容器
- 拓扑排序
- 环检测
- 最短路径
- 最小生成树

### 动态规划

解题步骤：

1. 定义状态（dp 表示的是什么？dp 用什么表示？）
2. 寻找状态转移方程
3. 先填充基础状态
4. 遍历并由小状态推导出大状态（可以反过来）

自底向上的好处：

- 消除了递归，因为不需要方法栈的空间，有更好的空间效率
- 取消了包装类，像 boolean 这种，当 true 和 false 都有可能时，会需要用包装类 Boolean

### 字符串

- 当所有字母都是小写或者都是大写的时候，可以用 `new int[26]` 来存储字符串，比如 c 对应的是 `int['c' - 'a']`，用 `new int[26]` 是用来代替 `Map<Character, Integer>` 解决装箱的开销的，字典树也是因为这个产生的，字典树的数据结构：

  ```java
  class TrieNode {
      TrieNode[] children = new TrieNode[26];
      int count = 0;
  }
  ```

- 注意区分字串和子序列，一个是连续的，一个是不连续的

- 字符串问题通常可以当成数组问题来解决

- 字符串常用的技巧：滑动窗口、动态规划、回溯、字典树、哈希表

### 递归
- 递归的本质是：**大问题转小问题**
- 当递归会分解为多个问题（重复问题）：转为动态规划问题，可以加入记忆表，自顶向下，然后根据状态转移方程，写出自底向上的动态规划

### 二分查找

看到 O(logn) 或者是有序数组时，优先想到二分法
注意点：

1. 记得要判断参数，比如：`if (nums == null || nums.length == 0) return -1;`
2. while 的条件：`while (lo <= hi)`
3. 取中值得方程式：`int mid = lo + hi >>> 1;`
4. 当需要走完 while 循环而不是直接 return，通过 `int ans = 0;` 来记录
5. 二分只是一种思想，不要拘泥于公式化的二分法，比如光是二分的对象就有下标和值，甚至其它的

### 数组

- 可以用指针来标注数组的范围，代替数组缩小，继进行内部修改可以达到 in-place 的效果
- 数组可以和哈希表配合，用 key 来记录数组的值，用 value 来记录 index，来达到快速定位的效果（通常需要数组的值唯一）
- 数组最常用的操作就是 swap
- 通常可以参考归并思想、快排思想、堆排思想、插入排序的思想

### 回溯
试错，全排列问题，N皇后，生成括号

* 剪枝（判断）通常有两个时机：
  1. 在 for 循环里面
  2. 在方法最前面判断

### 贪心
- 贪心通常是问题的最优解，**子问题最优解等于主问题最优解**，但是一般情况很难想到贪心法，需要经验积累


### 深度优先
**递归** 或者利用 **栈**
技巧：

- 用 directions 表示方向
- 可以利用返回值记录结果来规避成员变量
- 有两个判断点，分别是入栈前和出队后，在出栈后再判断比较好，因为可以覆盖到第一次入队

### 广度优先
利用 **队列**
技巧：

- 用 directions 表示方向  
- 用 int[] 来存储坐标  
- 有两个判断点，分别是入队前和出队后，在出队后再判断比较好，因为可以覆盖到第一次入队
- **每次都遍历完整个队列，每遍历一次 level++，这是 BFS 特有的优势**

### 栈

* 深度优先遍历
* 一些可以**两两抵消**的优先要想到栈，例如**括号**
* 判别是否需要使用单调栈，如果需要找到左边或者右边第一个比当前位置的数大或者小，则可以考虑使用单调栈；单调栈的题目如矩形米面积等等


### 队列

* 广度优先遍历

### 哈希表

- 哈希表配合数组时，可以用 key 存数组的值，而 value 存数组的下标（反过来）

## 算法解题注意点

1. 一定要处理边界问题，要做参数校验！
2. 当没有任何思路的时候 -> 