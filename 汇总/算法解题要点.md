## 算法解题步骤
1. 读题：看清题目，寻找关键字，如要求 O(nlogn) 复杂度，应该立刻想到二分查找，看到链表问题，立刻想到头节点和双指针

2. 得出解题思路：先想好要用什么方法，可以打下草稿，不要急着写代码
3. 将思路转变为代码：记住这三者不能乱，必须要按顺序来，不能没有思路瞎写代码，如果实在没有很好的思路，可以尝试先用比较粗暴的方法解决问题


## 读题到方法（认识关键字）
- 有序数组，复杂度 O(nlogn) -> 二分查找

- 生成所有结果 -> 回溯，试错，全排列问题
- 前 k 个 -> 优先队列
- 如果需要找到左边或者右边第一个比当前位置的数大或者小 -> 单调栈
- 重复子问题 -> 动态规划
- 无额外的空间复杂度 -> 原地算法，数组相关的操作
- 多重依赖关系 -> 图，拓扑排序
- 大问题转小问题 -> 递归  -> 动态规划

通用思路 -> 考虑使用栈、队列（双端队列更好用）、哈希表、Set 等数据结构解决问题

## 各类型问题解题技巧
#### 递归
大问题转小问题（核心），动态规划 - 自顶向下（加入记忆表）
当递归会分解为多个问题（重复问题）：转为动态规划问题，可以加入记忆表，自顶向下，然后根据状态转移方程，写出自底向上的动态规划

#### 回溯
试错，全排列问题，N皇后，生成括号

* 剪枝（判断）的时机很重要

#### 贪心
子问题最优解 == 大问题最优解时，可以用贪心，通常是最优得解法，但是比较难掌握使用的时机

#### 动态规划

两个核心问题：

1. 定义状态（dp 表示的是什么）
2. 寻找状态转移方程

自底向上的好处：

- 消除了递归，因为不需要栈的空间，有更好的时间效率
- 取消了包装类，像boolean这种，当true和false都有可能时，会需要用包装类Boolean

#### 深度优先
**递归**或者利用**栈**
技巧：

- 用 directions 表示方向
- 可以利用返回值记录结果来规避成员变量
- 有两个判断点，分别是入栈前和出队后，在出栈后再判断比较好，因为可以覆盖到第一次入队

#### 广度优先
利用**队列**
技巧：

- 用 directions 表示方向  
- 用 int[] 来存储坐标  
- 有两个判断点，分别是入队前和出队后，在出队后再判断比较好，因为可以覆盖到第一次入队
- **每次都遍历完整个队列，每遍历一次 level++，这是 BFS 特有的优势**

#### 链表
1. 头节点
2. 双指针（快慢指针，等距指针，...）
3. 善于拆分和组合链表
4. 善用反转操作
5. 善用归并操作
6. 注意：链表很容易形成循环链表，注意及时进行操作，curr.next = null 来避免循环链表

#### 树

- **递归**
- 栈
- 队列

#### 二叉搜索树

* 若左子树不为空，左子树上**所有**的节点小于根节点

* 若右子树不为空，右子树上**所有**的节点大于根节点

* 左子树和右子树都是二叉搜索树

特征：中序遍历是有序的

#### 二分查找
看到 O(logn) 或者是有序数组时，优先想到二分法
注意点：

1. lo <= hi
2. 比较条件

#### 数组
- 可以用指针来标注数组的缩小，替换数组原有结构，继进行内部修改可以达到 in-place 的效果


#### 单调栈

- 判别是否需要使用单调栈，如果需要找到左边或者右边第一个比当前位置的数大或者小，则可以考虑使用单调栈；单调栈的题目如矩形米面积等等



#### 栈

* 深度优先遍历
* 一些可以**两两抵消**的优先要想到栈，例如**括号**


#### 队列

* 广度优先遍历

#### 字符串

TODO

#### 哈希表

- 哈希表配合数组时，可以用 key 存数组的值，而 value 存数组的下标（反过来）