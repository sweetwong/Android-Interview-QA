## 原理
HashMap是通过**对 key 的 hash 值进行转换**来定位每个 key 在内部数组上的位置。HashMap 是实现原理是**数组+链表**，1.8以后加入了**红黑树**。

## Key的Hash值计算

第一步：**正常计算出 key 的 hash 值**（调用 key 的 hashCode() 方法，如果 key 是 null 则其 hash 值是0）；
第二步：**对得到的 hash 值进行扰乱**，目的是为了让 hash 值能尽可能的均匀分布。


## 问题

#### 1. 为什么不直接使用 key 而要使用 key 的 hash 值？
答：如果直接使用 key，那么在查找的时候需要调用 key 的 equals() 方法去逐个比较，时间复杂度从原本的 O(1) 变成了 O(n) ，且 equals() 比较的效率也很低，而通过 hash 值可以直接定位到桶。

#### 2. 那为什么又不直接用 hash 值作为数组上的索引？
答：为了防止数组下标越界，因为 hash 值不确定性，很容易越界。

#### 3. 那为什么用的是 (n - 1) & hash，而不是 hash % n 呐？
答：其实早期版本就是用 hash % n，但是为了追求效率，后来就改成了位运算 (n - 1) & hash（位运速度比取余算快（注意：%是取余不是取模））。
**当n为2的指数，(n - 1) & hash 与 hash % n是等价的**

#### 4. 为什么 (n - 1) & hash 和 hash % n 是等价的？
答：这里利用了 HashMap 的一个特性：HashMap 规定其容量必须是2的n次方（最大为230次方）,那么n肯定就是2xx次方了，用二进制表示就是1000...00，最前面是1，后面全是0(假设有k个0)，那么n-1就全变成1了111...1111（k-1个1），hash ^ (n - 1)得到的最大值就是n-1，最小值是0。效果和hash % n一样，只是改为位运算了。位运算比取模运算更快。

#### 5. 为什么 HashMap 的容量是2的幂次方
答：是为了 hash 值的计算，早期版本的 hash 值计算是 hash % n，来得到一个数组范围内的 hash 值，而当容量为2的幂次方（其二进制永远是100.....，再减去1，就是全部都是11111，方便做与运算），通过 (n - 1) & hash 来计算哈希值，会更加效率。


## 链接

[CSDN：Java（Android）数据结构汇总（四）-- Map（上）](https://www.jianshu.com/p/4c9576780588)