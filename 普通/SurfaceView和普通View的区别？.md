`View`

## 区别

1. View 底层没有双缓冲机制，SurfaceView 有**双缓冲机制**；

2. View 主要适用于主动更新，而 SurfaceView **适用与被动的更新**，如频繁的刷新

3. View 会在主线程中去更新UI，而 SurfaceView 则在**子线程中刷新**；


## 特征
SurfaceView 中采用了双缓冲机制，保证了UI界面的流畅性，同时 SurfaceView 不在主线程中绘制，而是另开辟一个线程去绘制，所以它不妨碍 UI 线程；

* View：显示视图，内置画布，提供图形绘制函数、触屏事件、按键事件函数等；必须在 UI 主线程内更新画面，速度较慢。

* SurfaceView：基于 view 视图进行拓展的视图类，更适合 2D 游戏的开发；是 view 的子类，类似使用双缓机制，在新的线程中更新画面所以刷新界面速度比 view 快，Camera 预览界面使用 SurfaceView。

* GLSurfaceView：基于 SurfaceView 视图再次进行拓展的视图类，专用于 3D 游戏开发的视图；是 SurfaceView 的子类，OpenGL 专用。 如何实现进程保活


## 问题的由来
**CPU 访问内存的速度要远远快于访问屏幕的速度**。如果需要绘制大量复杂的图像时，每次都一个个从内存中读取图形然后绘制到屏幕就会造成多次地访问屏幕，从而导致效率很低。这就跟CPU和内存之间还需要有三级缓存一样，需要提高效率。

####   第一层缓冲
在绘制图像时不用上述一个一个绘制的方案，**而采用先在内存中将所有的图像都绘制到一个 Bitmap 对象上，然后一次性将内存中的 Bitmap 绘制到屏幕，从而提高绘制的效率**。Android 中 View 的 onDraw() 方法已经实现了这一层缓冲。onDraw() 方法中不是绘制一点显示一点，而是都绘制完后一次性显示到屏幕。

#### 第二层缓冲（与普通的 View 不同的地方）

onDraw() 方法的 Canvas 对象是和屏幕关联的，而 onDraw() 方法是运行在 UI 线程中的，如果要绘制的图像过于复杂，则有可能导致应用程序卡顿，甚至 ANR。**因此我们可以先创建一个临时的 Canvas 对象，将图像都绘制到这个临时的 Canvas 对象中，绘制完成之后再将这个临时 Canvas 对象中的内容(也就是一个Bitmap)，通过 drawBitmap() 方法绘制到 onDraw() 方法中的 canvas 对象中**。这样的话就相当于是一个 Bitmap 的拷贝过程，比直接绘制效率要高，可以减少对 UI 线程的阻塞。

## 链接
[简书：Android自定义View之双缓冲机制和SurfaceView](https://www.jianshu.com/p/afe23814b207)