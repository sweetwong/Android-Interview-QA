`Java 并发`

## 结论

volatile 能保证可见性和有序性，不能保证原子性

## volatile 如何保证可见性和有序性？

当一个共享变量被 volatile 修饰时：
1. **它会保证修改的值会立即被更新到主存**
2. **当有其他线程需要读取时，它会去主存中读取新值**。保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
3. **禁止进行指令重排序**。

如上 3 条可知，volatile 可以保证单词操作的正确性，如单次的 get 或 set


## volatile 的实现原理
#### 1.可见性
处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。如果对声明了 volatile 变量进行写操作时，**JVM **会向**处理器**发送一条 **Lock 前缀的指令**，将这个变量所在缓存行的数据写会到系统内存。 **这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据**。但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过**嗅探**在总线上传播的数据来检查自己的缓存是否过期， 当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了 volatile 变量都是从主内存中获取最新的。
#### 2. 有序性
Lock 前缀指令实际上相当于一个**内存屏障**（Memory Barrier），**它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置**，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。

## 双重检查锁为什么要用 volatile？

知乎：

> 主要是禁止重排序，初始化一个实例（`SomeType st = new SomeType()`）不是一个**原子性操作**，在 Java 字节码中会有 4 个步骤
>
> 1. 申请内存空间
> 2. 初始化默认值（区别于构造器方法的初始化）
> 3. 执行构造器方法
> 4. 连接引用和实例
>
> 这4个步骤后两个有可能会重排序，1234、1243都有可能，造成未初始化完全的对象发布。
>
> volatile 可以通过内存屏障禁止指令重排序，从而避免这个问题。

维基百科：

> Intuitively, this algorithm seems like an efficient solution to the problem. However, this technique has many subtle problems and should usually be avoided. For example, consider the following sequence of events:
>
> 1. Thread *A* notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
> 2. Due to the semantics of some programming languages, the code generated by the compiler is allowed to update the shared variable to point to a **partially constructed object** before *A* has finished performing the initialization. For example, in Java if a call to a constructor has been inlined then the shared variable may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.[[6\]](https://en.wikipedia.org/wiki/Double-checked_locking#cite_note-IBM-6)
> 3. Thread *B* notices that the shared variable has been initialized (or so it appears), and returns its value. Because thread *B* believes the value is already initialized, it does not acquire the lock. If *B* uses the object before all of the initialization done by *A* is seen by *B* (either because *A* has not finished initializing it or because some of the initialized values in the object have not yet percolated to the memory *B* uses ([cache coherence](https://en.wikipedia.org/wiki/Cache_coherence))), the program will likely crash.

## 链接

[Github：android_interview：volatile](https://github.com/LRH1993/android_interview/blob/master/java/concurrence/volatile.md)

[博客园：为什么volatile不能保证原子性而Atomic可以？（从编译的角度来看）](https://www.cnblogs.com/mainz/p/3556430.html)

[Wikipedia：Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java)

[知乎：java 单例模式中双重检查锁定 volatile 的作用？](https://www.zhihu.com/question/56606703)

